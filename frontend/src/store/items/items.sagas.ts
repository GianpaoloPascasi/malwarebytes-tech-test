import {
  call,
  put,
  PutEffect,
  select,
  take,
  takeEvery,
} from "redux-saga/effects";
import { ITEMS_ACTIONS, updateItemAndShowItemModal } from "./items.actions";
import { ItemsApi } from "../../api/items";
import { Item, itemsSliceActions } from "./items.slice";
import { EventChannel, eventChannel } from "redux-saga";
import { PayloadAction } from "@reduxjs/toolkit";
import { selectJWT, selectOrder, selectUser } from "../user/user.selectors";
import { Order, User, userSliceActions } from "../user/user.slice";
import { OrdersApi } from "../../api/orders";
import { io } from "socket.io-client";
import { AppWebsocketResponse } from "../../models/websocket/response.model";
import { selectUiData } from "../ui/ui.selectors";
import { ADD_ITEM_ORDER_MODAL } from "../../components/items/AddItemToOrder";
import { uiSliceActions } from "../ui/ui.slice";
import { ITEM_CHANGED_QUANTITY_MODAL } from "../../components/items/ItemChangedQuantityModal";
import { selectItemById } from "./items.selectors";
import { ERROR_SNACKBAR } from "../../App";

function* getItems() {
  try {
    const items: Array<Item> = yield ItemsApi.fetchAll();
    yield put(itemsSliceActions.merge(items));
  } catch (e) {
    yield put(uiSliceActions.setUiData({
      uiElementName: ERROR_SNACKBAR,
      data: {
        show: true,
        msg: (e as Error).message,
      }
    }));
  }
}

function* watchGetItems() {
  yield takeEvery(ITEMS_ACTIONS.FETCH_ALL, getItems);
}

function websocketInitChannel() {
  return eventChannel((emitter) => {
    // init the connection here
    const ws = io(`${process.env.REACT_APP_WEBSOCKET_URL!}/items`, {
      transports: ["websocket"],
    });

    ws.on("connect", () => {
      console.log("Connected to items websocket");
    });

    ws.on("item.quantity.changed", (msg: AppWebsocketResponse<Item>) => {
      switch (msg.action) {
        case "UPDATE_ITEMS":
          // return emitter(itemsSliceActions.update(msg.data));
          return emitter(
            updateItemAndShowItemModal(msg.data, (msg as any).userId)
          );
        default:
        // nothing to do
      }
    });
    // unsubscribe function
    return () => {
      console.log("Item websocket off");
      ws.close();
    };
  });
}

function* websocketSaga(): any {
  try {
    // start websocket and channel
    const channel: EventChannel<any> = yield call(websocketInitChannel);
    while (true) {
      const action: PutEffect<any> = yield take(channel as any);
      yield put(action);
    }
  } catch (e) {
    yield put(uiSliceActions.setUiData({
      uiElementName: ERROR_SNACKBAR,
      data: {
        show: true,
        msg: (e as Error).message,
      }
    }));
  } finally {
    // channel diconnected
    console.log("Item websocket disconnected");
  }
}

function* updateItemAndShowModal(
  action: PayloadAction<{ item: Item; userId: number }>
) {
  const { item, userId } = action.payload;

  const addItemToOrderDialogData: { show: boolean } = yield select(
    selectUiData(ADD_ITEM_ORDER_MODAL)
  );
  /**
   * if the AddItemToOrder is not opened (it means it's not the user making the change)
   * show the ItemChangedQuantityModal
   */
  if (!addItemToOrderDialogData || addItemToOrderDialogData.show === false) {
    const existingItem: Item = yield select(selectItemById(item.id));
    const quantity = existingItem.quantity - item.quantity;

    yield put(
      uiSliceActions.setUiData({
        uiElementName: ITEM_CHANGED_QUANTITY_MODAL,
        data: {
          show: true,
          id: item.id,
          quantity: (quantity < 0 && -quantity) || quantity,
          isDecreased: quantity > 0,
        },
      })
    );
  }
  const userData: User = yield select(selectUser);
  const jwt: string = yield select(selectJWT);

  if (userData.id === userId) {
    const orders: Array<Order> = yield call(OrdersApi.getAll, jwt);
    yield put(userSliceActions.putOrders(orders));
  }
  // then update the slice to show the new quantity
  yield put(itemsSliceActions.update(item));
}

function* watchUpdateItemAndShowModal() {
  yield takeEvery(ITEMS_ACTIONS.UPDATE_AND_SHOW_MODAL, updateItemAndShowModal);
}

function* addItemToOrder(action: PayloadAction<number>) {
  try {
    let activeOrder: Order = yield select(selectOrder);
    const jwt: string = yield select(selectJWT);
    if (!activeOrder) {
      activeOrder = (yield call(OrdersApi.create, jwt)) as Order;
      yield put(
        userSliceActions.putOrders([
          {
            ...activeOrder,
            items: [],
          },
        ])
      );
    }

    const updatedOrder: Order = yield call(
      OrdersApi.addItemToOrder,
      activeOrder.id,
      action.payload,
      jwt
    );
    yield put(userSliceActions.updateOrder(updatedOrder));
  } catch (e) {
    yield put(uiSliceActions.setUiData({
      uiElementName: ERROR_SNACKBAR,
      data: {
        show: true,
        msg: (e as Error).message,
      }
    }));
  }
}

function* watchAddItemToOrder() {
  yield takeEvery(ITEMS_ACTIONS.ADD_ITEM_ORDER, addItemToOrder);
}

function* removeItemFromOrder(
  action: PayloadAction<{ orderId: number; itemId: number }>
) {
  try {
    let activeOrder: Order = yield select(selectOrder);
    const jwt: string = yield select(selectJWT);
    if (!activeOrder) {
      throw new Error("No active order found!");
    }
    const orderItemId = activeOrder.items.find(
      (item) => item.item.id === action.payload.itemId
    )!.id;
    const updatedOrder: Order = yield call(
      OrdersApi.removeItemFromOrder,
      activeOrder.id,
      orderItemId,
      jwt
    );
    yield put(userSliceActions.updateOrder(updatedOrder));
  } catch (e) {
    yield put(uiSliceActions.setUiData({
      uiElementName: ERROR_SNACKBAR,
      data: {
        show: true,
        msg: (e as Error).message,
      }
    }));
  }
}

function* watchRemoveItemFromOrder() {
  yield takeEvery(ITEMS_ACTIONS.REMOVE_ITEM_ORDER, removeItemFromOrder);
}

const itemsSagas = [
  watchGetItems,
  websocketSaga,
  watchAddItemToOrder,
  watchRemoveItemFromOrder,
  watchUpdateItemAndShowModal,
];
export default itemsSagas;
